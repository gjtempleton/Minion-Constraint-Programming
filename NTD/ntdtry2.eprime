language ESSENCE' 1.0

$Read in parameters for min and max numbers on dice sides as well as number of dice and sides
given dMin : int
given dMax : int
given d : int
given s : int

$Find the matrix of dice sides
find dice : matrix indexed by [int(1..d), int(1..s)] of int(dMin..dMax)

$Find the matrix of results from rolls, dx2, the two for how many times a dice wins and loses rolling against the next one
find rollMatrix : matrix indexed by [int(0..d-1), int(0..1)] of int(0..(s*s))

such that	  
  $Wins matrix filled, use mods to allow for overflow of last dice to first dice
  $Adds one to the sum for each roll where the value in the matrix for the current die's side "thisDie" is higher
  $Than that for the next die in the chain "nextDie"
  forAll x : int(0..d-1).
	(rollMatrix[x,0] =(sum thisDie,nextDie : int(1..s). (dice[1+(x % d), thisDie] > dice[1+((x + 1) % d), nextDie]))),
  
  $Losses filled
  forAll x : int(0..d-1).
	(rollMatrix[x,1] =
        (sum thisDie,nextDie : int(1..s). (dice[1+(x % d), thisDie] < dice[1+((x + 1) % d), nextDie]))),
   
   $Check on wins being better than losses - previous check based on higher than half of rolls didn't account for draws
  forAll x : int(0..d-1).
    rollMatrix[x, 0] > rollMatrix[x, 1]
	
	$Order the numbers on each die to make use of symmetry breaking, cuts down on memory use massively
  forAll x : int(1..d).
    (forAll i : int(2..s).
      dice[x,i-1] <= dice[x,i]),